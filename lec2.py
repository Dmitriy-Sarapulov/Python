# Данные, функции и модули в Python.

#  режимы для записи данныхЖ

#a - открытие для добавление данных( в случае если файла нет он будет создан)
#r - открытие для чтения данных (если файла нет, будет ошибка)
#w - открытие для записи данных

# data переменная для работы с данными

# data.writeline(colours) - запись данных в файл(в скобках аргумент для записи)

# colors = ['red', ' green', 'blue'] # запись данных в файл
# data = open('file.txt', 'a')
# data.writelines(colors)
# data.close()  - закрытие соединения с файлом, если не закрыть, то редактирование 
# и удаление файла будет невозможно
# data.write('\nline 2\n') - позволяет дописывать новую порцию данных \n резделение с 
# новой строки сможно ставить и до и после аргумента


# with open('file.exe', 'a') as data: - еще один вариант редактирования файла, добавить записи.
#     data.write('line 1111\n')
#     data.write('line 1221\n') - в этом случае не нужно вызывать в ручную закрытие файла

# exit() - функция которая позволяет не выполнять дальнейший код

# чтение данных из файла

# path = 'file.txt' # создаём путь к папке
# data = open(path, 'r') # открываем считывание файла
# for line in data:  # циклом пробегаемся по файлу
#     print(line)
# data.close()  #разрыв связи файловой переменной с файлом на диске

# Функции углубление

# Скрипты

# import lec1 # import - для вызова директории; lec1 - имя файла

# print(lec1.f(1)) # печатаем из файла lec1 ф-ю f(1) выводя в консоль резкльтат

# import lec1 as l # сокращаем имя файла для более локаничного кода
# print(l.f(1)) # выводим тоже самое, что и выше

# значения по умолчанию для функций

# def new_string(symbol, count): #принимает аргументом символ и число 
#def new_string(symbol, count = 3) задан каунт по умолчанию
#     return symbol * count  # Возвращаем умноженую строку на число (сахар пайтона)
# print(new_string('!', 5)) # Результат: !!!!!
# print(new_string('!')) #так будет работать только если каунт задан сразу


# передача большого кол-ва аргументов с помощью функции.

# def concatenatio(*params): #при описании функции перед аргументом ставим *
#     res: str = "" #  переменная: тип данных преобразуем результат в строку
#     for item in params: 
#         res += item
#     return res
# print(concatenatio('a', 's', 'd', 'w')) #asdw
# print(concatenatio('a', '1', 'd', '2')) #a1d2
# print(concatenatio(1, 2, 3, 4)) - ошибка будет работать если сделать res: int

# рекурсия 

# def fib(n): ф-я чисел фибаначи
#     if n in [1, 2]:
#         return 1
#     else:
#         return fib(n-1) + fib(n-2)

# list = []  вывод первых 10 чисел закономерности
# for e in range(1, 10):
#     list.append(fib(e))
# print(list) # 1 1 2 3 5 8 13 21 34

# Кортежи - не изменяемый список(можно переконвертировать в список и наоборот)тоже может содержать все типы данных

# a = (3, 4) # Кортеж
# print(a)

# print(a[0]) обращение к конкретному элементу массива

# b = (1, 2, 3) # работа с котежами с помощью цикла

# for item in b:
#     print(item)

# Распаковка кортежа в отдельные переменные

# t = tuple(['red', 'green', 'blue']) # создаем список, конвертируем в кортеж
# red, green, blue = t # распаковка кортежа до независимых переменных
# print('r{} g{} b{}'.format(red, green, blue))

# Словари - неупорядоченные коллекции произвольных объектов с доступом по ключу

dictionary = {} # объявление словаря
# dictionary = \
#     {
#         'up': 'Стрелка вверх', #'up': - ключ 'Стрелка вверх'- значение
#         'down': 'Стрелка вниз'
#     }
# print(dictionary) # печать словаря
# print(dictionary['down']) # обращение к ключу словаря

# dictionary['up'] = 'up' #изменение значения словаря

# Показать все ключи и все значения

# for k in dictionary.keys(): # dictionary.values -посмотреть конкретные значения
#     print(k)

# Множества - содержит уникальные элементы(про порядок никто не говорит)

# colours = {'red', 'green', 'blue'} # это множество
# print(type(colours)) 
# colours.add('grey') # добавление значений во множество(при добавлении одинакового резулььтат не изменится)
# print((colours))
# colours.remove('red') # Удаление элемента из множества(нельзя удалить то, чего нет)
# print((colours)) 
# colours.discard('red') # Удалить в виде исключения(если файла нет, не вызовет ошибку(разобраться))
# colours.clear # Очистить множество и работать "с чистого листа"

# a = {1, 2, 3, 5, 8}  # Определили 1 множемство
# b = {2, 5, 8, 13, 21} # Второе множество
# c = a.copy() # Создать идентичное множество(в кач-ве аргумета пример)
# u = a.union(b) #Объединить множества
# i = a.intersection(b) # ВЫявить повторяющиеся элементы
# dl = a.difference(b) # выявить,что не входит в множество а
# dr = b.difference(a) # тоже самое с b 

# q = a \
#     .union(b) \
#     .difference(a.intersection(b))

# s = frozenset(a) # Создание замороженного(не изменяемого множества)

# еще списки

# list1 = [1,2,3,4,5]
# list2 = list1 # При таком раскладае в внесении изменений будут меняться оба списка

# for e in list1:
#     print(e)
# print()

# for e in list2:
#     print(e)
# print()

# print(list1.pop(2)) # удаление 2 элемента списка ф-я pop
# print(list1.insert(2, 11)) # "2" - позиция "11" -добавляемый элемент
# print(list1.append(11)) # добавление элемента в конец

 




