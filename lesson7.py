# Урок 7. Python: от простого к практике(ООП в пайтон)

#2 вида программирования, объектно ориентированное программирование и функциональное.
# зачем нужны классы? Класс описывет некую сущность. Класс-это чертеж или шаблон сущности.
# Объект(Экземпляр) - конкретная модель, изготовленная по четрежу с некоторыми атрибутами
# Атрибут- бывают 2-ух уровней(1-ый на уровне класса(то что не меняется))
# (2-ой на уровне объекта(то что может меняться))
# Метод - это контструктор класса, метод это последовательность дейстий, варианты действий.
# У класса есть Объект(экземпляр), У Объектов есть атрибуты(свойства) и методы( те или иные операции).

# Перегрузка - это моделирование метода по своим параметрам

class Lada: # Объяление класса класс с Большой буквы
    n_of_wheels = 4 #Атрибуты на уровне класса(кторые не меняются изначально)
    rule = 1

def __init__(self, color,engine): # атрибуты которые будут меняться инит вызывается всегда -это конструктор
    self.color = color # self ссылка на объект атрибут внутри класса!!!
    self.engine = engine

def method(self):# Это та же самая функция, принимает на вход ссылку на объект.
    print(Lada.rule)
    print(self.rule)
    self.rule = 2
    print()
    print()
    print()

def __str__(self):
    return "!"

obj = Lada('red', 'gas')

# __init__ - зарезервированная функция, одна из многих. (__str__)

# перегрузка пример:

obj = Lada('red', 'gas')
print(obj) # таким образом мы ввыведем тип данных, со ссылкой на область памяти.
# Если нас не устраивает такой вывод, мы выполняем перегрузку.
# Когла мы вызываем print(obj) по капотом выполняется следующий метод:
def __str__(self):
    return "!"

# как понять,что нужно перегружать? ТОлько выучить и практиковаться.(так же гугл) 
# Можно ли сложить объект типа данных str? ДА! Это будет конкотенация. 
# А можно ли сложить объекты?

obj_1 = Lada('red', 'gas')
obj_2 = Lada('red', 'gas')
print(obj_1 + obj_2) # Нет так как он не знает эти типы данных(потому что класс Lada создали вы)
# Но можно их перегрузить: 
# под капотом для функции сложения вызывается метод __add__ его нам и нужно перегрузить. 
def __add__(self, other): #self - ссылка на певрый объект, other - на второй
    print("!!") 
print(obj_1 + obj_2)
# После этого ошибки не будет.


class Item:
    c = 'Китай'

    def __init__(self, *args):
        self.name = args[0]
        self.price = int(args[1])
        self.a = args[2]
    
    def get_count(self):
        self.price -= 100

obj_1 = Item('Холодильник Самсунг', '500', '20/20/20')
obj_1 = Item('LG', '500', '20/20/20')
obj_1.new_attr = 1000
print (obj_1.__dict__) # атрибуты объекта хранятся в словаре.
# Использование словарей ограничить, занимают много памяти

# Проекты состоящие из множества .py файлов называются многослойные(монолитые) одна из самых неудачных 
# для больших проектов, так как все файлы связаны между собой(ошибка возникает из-за одного,
# а отражаться будет в другом.)

# Лучший вариант созания проекта - это микросервисы. (множество небольших программ связанных через http вызовы)
# Большие проекты, дробятся на небольшие и разботают через http вызовы.

#3 принципа ООП Инкапсуляция, полиморфизм и наследование
# Атрибуты + методы = интерфейс класса.
# Клиентский код - это то что происходит вне класса. (вызов методов и тд.)

# Инкапсуляция - сокрытие логики от клиентского кода(инкапсуляция в пайтон, формальная)работает для атрибутов 
# и методов
# Для этого используется 3 типа Атрибутов.
# 1)без(_) public
# 2)protected _атрибут атрибут недоступный вне класса(можно, но не нужно, для служебного использования)
# 3)privat __атрибут скрывает компоненты кода.(доступен только в рамках класса)

class Auto:

    def __init__(self):
        self.auto_name = 'Mazda' # Public
        self._auto_year = 2019 # Protected
        self.__auto_model = 'CX9' # Privat
    
    def func(self):
        print(self._auto_year)
        self.__auto_model = 2020

a = Auto()
print(a._Auto__automodel)

# Инкапсуляция для методов

class MyClass:
    __attr = 'значение'
    def __method(self): #protected метод
        print('Это защищенный метод')

mc = MyClass()
mc.__method()
print(mc.__attr)

# Наследование - это передача потомку интерфейса предка (можем вынести методы и атрибуты, что бы не 
# дублировать предка)

class User: # Основной класс(предок) с базовыми атрибутами от которого все наследуют 
    name = None
    surname = None

    def get_name(self):
        self.name = 'Ivanov'
        print(self.name)

class Teacher(User): # Потомок(наследник)
    pass

    def get_name(self): # Потомок(Наследник) Переопределенный метод.
        pass

class Student(User):
    pass # Заглушка. Когда вы точно знаете,что есть метод, но вы ещё не знаете его код.

obj = Student()

# Переопределение - клонирование объекта класса в другом классе(совпадает название метода, но разная логика)
# Если у потомка нет вызываемого атрибута, будут вызываться атрибуты предка.
# Переопределение - расширение возможности класса.
# Имеет место быть, множественное наследование(При совпадении будет вызываться атрибут первого предка)
# Определить базовый класс, и вынести в него все общие атрибуты и методы, характерные всем наследникам.

# super().classname - запрашивает атрибуты у предка(наследует), (обратись к предку)

class Shape: 
    def __init__(self, color, param_1, param_2):
        self.color = color
        self.param_1 = param_1
        self.param_2 = param_2
    
    def square(self):
        return self.param_1 * self.param_2

class Rectangle(Shape):
    def __init__(self, color, param_1, param_2, rectangle_p): # Передаются 4 параметра
        #(super говорит о том,что 3 из них берутся у предка)
        super().__init__(color, param_1, param_2) # super() в скобках ничего не пришем, просто обращение
        self.rectangle_p = rectangle_p # Уникальный параметр.

    def get_r_p(self):
        return self.rectangle_p

class Triangle(Shape): 
    def __init__(self, color, param_1, param_2, triangle_p):
        super().__init__(color, param_1, param_2)
        self.triangle_p = triangle_p

    def get_t_p(self):
        return self.triangle_p

r = Rectangle('White', 10, 20, True)
print(r.color)
print(r.square())
print(r.get_r_p())
t = Triangle('Red', 30, 40, False)
rint(t.color)
print(t.square())
print(t.get_t_p())

# Множественное наследование(больше 2-3 предков почти не встречается)

class Player:
    def player_method(self):
        print('Родительский метод класса Player')

class Navigator:
    def navigator_mathod(self):
        print('Родительский метод класса Navigator')

class MobilePhone(Player, Navigator):
    def mobile_phone_method(self):
        print('Дочерний метод класса MobilePhone')

m_p = MobilePhone()
m_p.player_mathod()
m_p.navigator_method()

# Полиморфизм(имеющий многие формы) - одинаковые название методов и разная логика(не обязательно нследник и предок)
# Нет наследования
class Auto:
    def auto_start(self, param_1, param_2 = None): # Полиморфизм
        if param_2 is not None:
            print(param_1 + param_2)
        else:
            print(param_1)

class Car:
    def auto_start(self, param_1, param_2 = None): # Полиморфизм
        pass

a = Auto()
c = Car()

lst = [a, c]
for el in list:
    print(el.auto_start(1, 2))

a = Auto()
a.auto_start(50)
a = Auto()
a.auto_start(10, 20)

# Если есть Наследование, то это будет переопределние,а не полиморфизм.

# именные функции (простейшие именные функции)
# from sys import argv
def first_func(*args): # *args - это массив из любого числа аргументов(кортеж). 
    # **kwargs - словарь
    print(args) # защита от перезаписи(кортеж, а не список)
    return args

# print(first_func(10, 20, 30))
def first_func(*kwargs): # *args - это массив из любого числа аргументов(кортеж). 
    # **kwargs - словарь
    print(kwargs) # защита от перезаписи(кортеж, а не список)
    return kwargs
print(first_func(a = 10, b = 20, c = 30)) #name = name именованная переменная

name = input() # запрос позиционной переменной.
print(first_func(name)) #Позиционная переменная.
print(first_func(name = name)) #Именованая переменная.

# запуск скрипта с параметрами.
# Импортирование в Python
#Скрипт = программа = процесс
from sys import argv # в модуле sys есть компонент argv он и позволяет нам достучаться до этих парам.

script_name, first_param, second_param = argv

print('имя скрипта: ', script_name)
print('имя первого параметра', first_param)
print('имя второго параметра', second_param)

# Импорты(import)

# все импорты выполняются строго в начале модуля

# Импортируем не целиком модуль,а отдельные компоненты. Экономим память

# есть 3 вида импортируемых компонентов

# 1) встроенные(из коробки) - из импортируемой стандартной библиотеки(стандартные компоненты)

import time
import random
print(time.time())
print(random.random())

# 2) сторонние модули, которые вы доустановили

# import numpy
# import django

# 3) модули которые мы сами создаём.
import lesson1 # из своего модуля могу импортировать любой класс,функцию,переменную и работаю как хочу.